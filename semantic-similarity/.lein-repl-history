quit
(.contains "Hello World" "Hello")
(conj [] "a")
(conj ["b"] "a")
(reduce #(conj %1 %2) [] {:a 1 :b 2})
clojure.string
(use 'clojure.string)
(clojure.string/split-str)
(clojure.string/split "Hello" #" ")
(.indexOf :a [:a])
(.indexOf [:a] :a)
(.indexOf "Hello" "ll")
(.indexOf "Hello" "lll")
(.indexOf "       => canine, canid" "=>")
5/4
(apply concat (((["dog" 0])(["cat" 0]))))
(keys {:a 1 :b 2})
(def dog {:name "brat"})
(def my-home {:dog dog})
(def jareds-home {:dog dog})
(jareds-home :dog)
(def n nil)
(nil? n)
(count {:a 1 :b 2})
(reverse (range (count {:a 1 :b 2})))
 (range (count {:a 1 :b 2}))
(reverse (vector (range (count {:a 1 :b 2}))))
quit
(count "TC grows technological organisms (in contrast to technological organelles currently in production) with the goal of reducing the marginal cost of human life thereby decreasing the threshold of "ramen profitability" for ambitious people.")
(count "TC grows technological organisms (in contrast to technological organelles currently in production) with the goal of reducing the marginal cost of human life thereby decreasing the threshold of 'ramen profitability' for ambitious people.")
(count "TC grows technological organisms (in contrast to technological organelles)")
(count "TC grows tech organisms w/ symbiotic sideffects.")
(count "Grow technological organisms that increase the production of the limiting factors to sentient life"
)
(count "Bringing a technological version of James Cameron's dream of Pandora to reality")
(count "Bringing James Cameron's dream of Pandora to reality")
(count "An element of James Cameron's vision of Pandora brought to reality")
(count "Element of James Cameron's Pandora brought to reality")
(count "Elements of James Cameron's Pandora made real")
quit
(quit)
(list {:a 1} {:b 2})
(def l (list {:a 1} {:b 2}))
(filter (fn [x] (println x) true) l)
(quit)
(def r (repeatedly rand))
(take 1 r)
(take 2 r)
(doall r)
(quit)
(def e 2.7182818284590452353602874713527)
e
(quit)
(require '[clojure.math.numeric-tower])
(/ 1 500)
(/ 1.0 500.0)
(* .002 .002)
(* 0.002 0.002)
(/ 1 (* 0.002 0.002))
(= "a" "b" "c")
(= "a" "a" "b")
(= "a" "a" "a")
(def a false)
(not a)
(def a {})
(if a 1 2)
 
quit
(def foo {:a 1 :b 2 :d 3})
(def bar {:a1 :b 2 :c 3})
(def bar {:a 1 :b 2 :c 3})
(map (fn [x y] (+ x y)) foo bar)
(split "Hello world" #" ")
(use '[clojure.string :only [split]])
(split "Hello world" #" ")
quit
(/ 11000 60)
(/ 11000 60.0)
(/ 182 24.0)
quit
(log 10)
(math/log 10)
(Math/log 10)
quit
(sorted-map "a" "b" "c")
(sorted-set "a" "b" "c")
(index (sorted-set "a" "b") "a")
(list (sorted-set "b" "a"))
(apply list (sorted-set "b" "a"))
(into [] (sorted-set "b" "a"))
(.indexOf (into [] (sorted-set "b" "a")) "a")
(defmacro printit [a b] `(print :a :b))
(print :a :b)
(printit :a :b)
quit
.indexOf
(.indexOf "a" "a")
(.indexOf "ba" "a")
(into [] {:a "b" :c "d"})
:)
(def word-&-freq 5)
(let [[a b][:
(let [[a b]["a" "b"]]
(print a b))
 
quit
